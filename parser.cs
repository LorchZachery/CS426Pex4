/* This file was generated by SableCC (http://www.sablecc.org/). */

using System;
using System.Collections;
using System.Text;
using System.IO;
using ToyLanguage.node;
using ToyLanguage.lexer;
using ToyLanguage.analysis;

namespace ToyLanguage.parser {

public class ParserException : ApplicationException
{
    Token token;

    public ParserException(Token token, String  message) : base(message)
    {
        this.token = token;
    }

    public Token Token
    {
      get { return token; }
    }
}

internal class State
{
    internal int state;
    internal ArrayList nodes;

    internal State(int state, ArrayList nodes)
    {
        this.state = state;
        this.nodes = nodes;
    }
}

internal class TokenIndex : AnalysisAdapter
{
    internal int index;

    public override void CaseTAssign(TAssign node)
    {
        index = 0;
    }

    public override void CaseTPlus(TPlus node)
    {
        index = 1;
    }

    public override void CaseTMult(TMult node)
    {
        index = 2;
    }

    public override void CaseTEol(TEol node)
    {
        index = 3;
    }

    public override void CaseTLparen(TLparen node)
    {
        index = 4;
    }

    public override void CaseTRparen(TRparen node)
    {
        index = 5;
    }

    public override void CaseTComma(TComma node)
    {
        index = 6;
    }

    public override void CaseTId(TId node)
    {
        index = 7;
    }

    public override void CaseTInteger(TInteger node)
    {
        index = 8;
    }

    public override void CaseTString(TString node)
    {
        index = 9;
    }

    public override void CaseEOF(EOF node)
    {
        index = 10;
    }
}

public class Parser
{
    private Analysis ignoredTokens = new AnalysisAdapter();
    public Analysis IgnoredTokens
    {
      get { return ignoredTokens; }
    }

    protected ArrayList nodeList;

    private Lexer lexer;
    private Stack stack = new Stack();
    private int last_shift;
    private int last_pos;
    private int last_line;
    private Token last_token;
    private TokenIndex converter = new TokenIndex();
    private int[] action = new int[2];

    private const int SHIFT = 0;
    private const int REDUCE = 1;
    private const int ACCEPT = 2;
    private const int ERROR = 3;

    public Parser(Lexer lexer)
    {
        this.lexer = lexer;
    }

    private int GoTo(int index)
    {
        int state = State();
        int low = 1;
        int high = gotoTable[index].Length - 1;
        int value = gotoTable[index][0][1];

        while(low <= high)
        {
            int middle = (low + high) / 2;

            if(state < gotoTable[index][middle][0])
            {
                high = middle - 1;
            }
            else if(state > gotoTable[index][middle][0])
            {
                low = middle + 1;
            }
            else
            {
                value = gotoTable[index][middle][1];
                break;
            }
        }

        return value;
    }

    private void Push(int numstate, ArrayList listNode)
    {
        this.nodeList = listNode;

        stack.Push(new State(numstate, this.nodeList));
    }

    private int State()
    {
        State s = (State) stack.Peek();
        return s.state;
    }

    private ArrayList Pop()
    {
        return (ArrayList) ((State) stack.Pop()).nodes;
    }

    private int Index(Switchable token)
    {
        converter.index = -1;
        token.Apply(converter);
        return converter.index;
    }

    public Start Parse()
    {
        Push(0, null);

        IList ign = null;
        while(true)
        {
            while(Index(lexer.Peek()) == -1)
            {
                if(ign == null)
                {
                    ign = new TypedList(NodeCast.Instance);
                }

                ign.Add(lexer.Next());
            }

            if(ign != null)
            {
                ignoredTokens.SetIn(lexer.Peek(), ign);
                ign = null;
            }

            last_pos = lexer.Peek().Pos;
            last_line = lexer.Peek().Line;
            last_token = lexer.Peek();

            int index = Index(lexer.Peek());
            action[0] = actionTable[State()][0][1];
            action[1] = actionTable[State()][0][2];

            int low = 1;
            int high = actionTable[State()].Length - 1;

            while(low <= high)
            {
                int middle = (low + high) / 2;

                if(index < actionTable[State()][middle][0])
                {
                    high = middle - 1;
                }
                else if(index > actionTable[State()][middle][0])
                {
                    low = middle + 1;
                }
                else
                {
                    action[0] = actionTable[State()][middle][1];
                    action[1] = actionTable[State()][middle][2];
                    break;
                }
            }

            switch(action[0])
            {
                case SHIFT:
        {
            ArrayList list = new ArrayList();
            list.Add(lexer.Next());
                        Push(action[1], list);
                        last_shift = action[1];
                    }
        break;
                case REDUCE:
                    switch(action[1])
                    {
                    case 0:
        {
      ArrayList list = New0();
      Push(GoTo(0), list);
        }
        break;
                    case 1:
        {
      ArrayList list = New1();
      Push(GoTo(1), list);
        }
        break;
                    case 2:
        {
      ArrayList list = New2();
      Push(GoTo(1), list);
        }
        break;
                    case 3:
        {
      ArrayList list = New3();
      Push(GoTo(2), list);
        }
        break;
                    case 4:
        {
      ArrayList list = New4();
      Push(GoTo(2), list);
        }
        break;
                    case 5:
        {
      ArrayList list = New5();
      Push(GoTo(2), list);
        }
        break;
                    case 6:
        {
      ArrayList list = New6();
      Push(GoTo(3), list);
        }
        break;
                    case 7:
        {
      ArrayList list = New7();
      Push(GoTo(4), list);
        }
        break;
                    case 8:
        {
      ArrayList list = New8();
      Push(GoTo(5), list);
        }
        break;
                    case 9:
        {
      ArrayList list = New9();
      Push(GoTo(6), list);
        }
        break;
                    case 10:
        {
      ArrayList list = New10();
      Push(GoTo(6), list);
        }
        break;
                    case 11:
        {
      ArrayList list = New11();
      Push(GoTo(7), list);
        }
        break;
                    case 12:
        {
      ArrayList list = New12();
      Push(GoTo(8), list);
        }
        break;
                    case 13:
        {
      ArrayList list = New13();
      Push(GoTo(8), list);
        }
        break;
                    case 14:
        {
      ArrayList list = New14();
      Push(GoTo(9), list);
        }
        break;
                    case 15:
        {
      ArrayList list = New15();
      Push(GoTo(9), list);
        }
        break;
                    case 16:
        {
      ArrayList list = New16();
      Push(GoTo(10), list);
        }
        break;
                    case 17:
        {
      ArrayList list = New17();
      Push(GoTo(10), list);
        }
        break;
                    case 18:
        {
      ArrayList list = New18();
      Push(GoTo(10), list);
        }
        break;
                    }
                    break;
                case ACCEPT:
                    {
                        EOF node2 = (EOF) lexer.Next();
                        PProg node1 = (PProg) ((ArrayList)Pop())[0];
                        Start node = new Start(node1, node2);
                        return node;
                    }
                case ERROR:
                    throw new ParserException(last_token,
                        "[" + last_line + "," + last_pos + "] " +
                        errorMessages[errors[action[1]]]);
            }
        }
    }

    ArrayList New0()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PStmts pstmtsNode2 = (PStmts)nodeArrayList1[0];
        AProg pprogNode1 = new AProg (
              pstmtsNode2
        );
        nodeList.Add(pprogNode1);
        return nodeList;
    }
    ArrayList New1()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList2 = (ArrayList) Pop();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PStmts pstmtsNode2 = (PStmts)nodeArrayList1[0];
        PStmt pstmtNode3 = (PStmt)nodeArrayList2[0];
        AMultipleStmts pstmtsNode1 = new AMultipleStmts (
              pstmtsNode2,
              pstmtNode3
        );
        nodeList.Add(pstmtsNode1);
        return nodeList;
    }
    ArrayList New2()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PStmt pstmtNode2 = (PStmt)nodeArrayList1[0];
        ASingleStmts pstmtsNode1 = new ASingleStmts (
              pstmtNode2
        );
        nodeList.Add(pstmtsNode1);
        return nodeList;
    }
    ArrayList New3()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PAssignstmt passignstmtNode2 = (PAssignstmt)nodeArrayList1[0];
        AAssignStmt pstmtNode1 = new AAssignStmt (
              passignstmtNode2
        );
        nodeList.Add(pstmtNode1);
        return nodeList;
    }
    ArrayList New4()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PDeclarestmt pdeclarestmtNode2 = (PDeclarestmt)nodeArrayList1[0];
        ADeclStmt pstmtNode1 = new ADeclStmt (
              pdeclarestmtNode2
        );
        nodeList.Add(pstmtNode1);
        return nodeList;
    }
    ArrayList New5()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PFunctioncall pfunctioncallNode2 = (PFunctioncall)nodeArrayList1[0];
        AFcStmt pstmtNode1 = new AFcStmt (
              pfunctioncallNode2
        );
        nodeList.Add(pstmtNode1);
        return nodeList;
    }
    ArrayList New6()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList4 = (ArrayList) Pop();
        ArrayList nodeArrayList3 = (ArrayList) Pop();
        ArrayList nodeArrayList2 = (ArrayList) Pop();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        TId tidNode2 = (TId)nodeArrayList1[0];
        TAssign tassignNode3 = (TAssign)nodeArrayList2[0];
        PExpr pexprNode4 = (PExpr)nodeArrayList3[0];
        TEol teolNode5 = (TEol)nodeArrayList4[0];
        AAssignstmt passignstmtNode1 = new AAssignstmt (
              tidNode2,
              tassignNode3,
              pexprNode4,
              teolNode5
        );
        nodeList.Add(passignstmtNode1);
        return nodeList;
    }
    ArrayList New7()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList3 = (ArrayList) Pop();
        ArrayList nodeArrayList2 = (ArrayList) Pop();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        TId tidNode2 = (TId)nodeArrayList1[0];
        TId tidNode3 = (TId)nodeArrayList2[0];
        TEol teolNode4 = (TEol)nodeArrayList3[0];
        ADeclarestmt pdeclarestmtNode1 = new ADeclarestmt (
              tidNode2,
              tidNode3,
              teolNode4
        );
        nodeList.Add(pdeclarestmtNode1);
        return nodeList;
    }
    ArrayList New8()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList5 = (ArrayList) Pop();
        ArrayList nodeArrayList4 = (ArrayList) Pop();
        ArrayList nodeArrayList3 = (ArrayList) Pop();
        ArrayList nodeArrayList2 = (ArrayList) Pop();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        TId tidNode2 = (TId)nodeArrayList1[0];
        TLparen tlparenNode3 = (TLparen)nodeArrayList2[0];
        PArguments pargumentsNode4 = (PArguments)nodeArrayList3[0];
        TRparen trparenNode5 = (TRparen)nodeArrayList4[0];
        TEol teolNode6 = (TEol)nodeArrayList5[0];
        AFunctioncall pfunctioncallNode1 = new AFunctioncall (
              tidNode2,
              tlparenNode3,
              pargumentsNode4,
              trparenNode5,
              teolNode6
        );
        nodeList.Add(pfunctioncallNode1);
        return nodeList;
    }
    ArrayList New9()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList3 = (ArrayList) Pop();
        ArrayList nodeArrayList2 = (ArrayList) Pop();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PArgument pargumentNode2 = (PArgument)nodeArrayList1[0];
        TComma tcommaNode3 = (TComma)nodeArrayList2[0];
        PArguments pargumentsNode4 = (PArguments)nodeArrayList3[0];
        AMultipleArguments pargumentsNode1 = new AMultipleArguments (
              pargumentNode2,
              tcommaNode3,
              pargumentsNode4
        );
        nodeList.Add(pargumentsNode1);
        return nodeList;
    }
    ArrayList New10()
    {
        ArrayList nodeList = new ArrayList();
        ANoneArguments pargumentsNode1 = new ANoneArguments (
        );
        nodeList.Add(pargumentsNode1);
        return nodeList;
    }
    ArrayList New11()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PExpr pexprNode2 = (PExpr)nodeArrayList1[0];
        AArgument pargumentNode1 = new AArgument (
              pexprNode2
        );
        nodeList.Add(pargumentNode1);
        return nodeList;
    }
    ArrayList New12()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList3 = (ArrayList) Pop();
        ArrayList nodeArrayList2 = (ArrayList) Pop();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PExpr pexprNode2 = (PExpr)nodeArrayList1[0];
        TPlus tplusNode3 = (TPlus)nodeArrayList2[0];
        PExpr2 pexpr2Node4 = (PExpr2)nodeArrayList3[0];
        APlusExpr pexprNode1 = new APlusExpr (
              pexprNode2,
              tplusNode3,
              pexpr2Node4
        );
        nodeList.Add(pexprNode1);
        return nodeList;
    }
    ArrayList New13()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PExpr2 pexpr2Node2 = (PExpr2)nodeArrayList1[0];
        APassExpr pexprNode1 = new APassExpr (
              pexpr2Node2
        );
        nodeList.Add(pexprNode1);
        return nodeList;
    }
    ArrayList New14()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList3 = (ArrayList) Pop();
        ArrayList nodeArrayList2 = (ArrayList) Pop();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        PExpr2 pexpr2Node2 = (PExpr2)nodeArrayList1[0];
        TMult tmultNode3 = (TMult)nodeArrayList2[0];
        POperand poperandNode4 = (POperand)nodeArrayList3[0];
        AMultExpr2 pexpr2Node1 = new AMultExpr2 (
              pexpr2Node2,
              tmultNode3,
              poperandNode4
        );
        nodeList.Add(pexpr2Node1);
        return nodeList;
    }
    ArrayList New15()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        POperand poperandNode2 = (POperand)nodeArrayList1[0];
        APassExpr2 pexpr2Node1 = new APassExpr2 (
              poperandNode2
        );
        nodeList.Add(pexpr2Node1);
        return nodeList;
    }
    ArrayList New16()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        TInteger tintegerNode2 = (TInteger)nodeArrayList1[0];
        AIntOperand poperandNode1 = new AIntOperand (
              tintegerNode2
        );
        nodeList.Add(poperandNode1);
        return nodeList;
    }
    ArrayList New17()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        TId tidNode2 = (TId)nodeArrayList1[0];
        AVariableOperand poperandNode1 = new AVariableOperand (
              tidNode2
        );
        nodeList.Add(poperandNode1);
        return nodeList;
    }
    ArrayList New18()
    {
        ArrayList nodeList = new ArrayList();
        ArrayList nodeArrayList1 = (ArrayList) Pop();
        TString tstringNode2 = (TString)nodeArrayList1[0];
        AStringOperand poperandNode1 = new AStringOperand (
              tstringNode2
        );
        nodeList.Add(poperandNode1);
        return nodeList;
    }

    private static int[][][] actionTable = {
      new int[][] {
        new int[] {-1, 3, 0},
        new int[] {7, 0, 1},
      },
      new int[][] {
        new int[] {-1, 3, 1},
        new int[] {0, 0, 8},
        new int[] {4, 0, 9},
        new int[] {7, 0, 10},
      },
      new int[][] {
        new int[] {-1, 3, 2},
        new int[] {10, 2, -1},
      },
      new int[][] {
        new int[] {-1, 1, 0},
        new int[] {7, 0, 1},
      },
      new int[][] {
        new int[] {-1, 1, 2},
      },
      new int[][] {
        new int[] {-1, 1, 3},
      },
      new int[][] {
        new int[] {-1, 1, 4},
      },
      new int[][] {
        new int[] {-1, 1, 5},
      },
      new int[][] {
        new int[] {-1, 3, 8},
        new int[] {7, 0, 12},
        new int[] {8, 0, 13},
        new int[] {9, 0, 14},
      },
      new int[][] {
        new int[] {-1, 1, 10},
        new int[] {7, 0, 12},
        new int[] {8, 0, 13},
        new int[] {9, 0, 14},
      },
      new int[][] {
        new int[] {-1, 3, 10},
        new int[] {3, 0, 21},
      },
      new int[][] {
        new int[] {-1, 1, 1},
      },
      new int[][] {
        new int[] {-1, 1, 17},
      },
      new int[][] {
        new int[] {-1, 1, 16},
      },
      new int[][] {
        new int[] {-1, 1, 18},
      },
      new int[][] {
        new int[] {-1, 3, 15},
        new int[] {1, 0, 22},
        new int[] {3, 0, 23},
      },
      new int[][] {
        new int[] {-1, 1, 13},
        new int[] {2, 0, 24},
      },
      new int[][] {
        new int[] {-1, 1, 15},
      },
      new int[][] {
        new int[] {-1, 3, 18},
        new int[] {5, 0, 25},
      },
      new int[][] {
        new int[] {-1, 3, 19},
        new int[] {6, 0, 26},
      },
      new int[][] {
        new int[] {-1, 1, 11},
        new int[] {1, 0, 22},
      },
      new int[][] {
        new int[] {-1, 1, 7},
      },
      new int[][] {
        new int[] {-1, 3, 22},
        new int[] {7, 0, 12},
        new int[] {8, 0, 13},
        new int[] {9, 0, 14},
      },
      new int[][] {
        new int[] {-1, 1, 6},
      },
      new int[][] {
        new int[] {-1, 3, 24},
        new int[] {7, 0, 12},
        new int[] {8, 0, 13},
        new int[] {9, 0, 14},
      },
      new int[][] {
        new int[] {-1, 3, 25},
        new int[] {3, 0, 29},
      },
      new int[][] {
        new int[] {-1, 1, 10},
        new int[] {7, 0, 12},
        new int[] {8, 0, 13},
        new int[] {9, 0, 14},
      },
      new int[][] {
        new int[] {-1, 1, 12},
        new int[] {2, 0, 24},
      },
      new int[][] {
        new int[] {-1, 1, 14},
      },
      new int[][] {
        new int[] {-1, 1, 8},
      },
      new int[][] {
        new int[] {-1, 1, 9},
      },
    };

    private static int[][][] gotoTable  = {
      new int[][] {
        new int[] {-1, 2},
      },
      new int[][] {
        new int[] {-1, 3},
      },
      new int[][] {
        new int[] {-1, 4},
        new int[] {3, 11},
      },
      new int[][] {
        new int[] {-1, 5},
      },
      new int[][] {
        new int[] {-1, 6},
      },
      new int[][] {
        new int[] {-1, 7},
      },
      new int[][] {
        new int[] {-1, 18},
        new int[] {26, 30},
      },
      new int[][] {
        new int[] {-1, 19},
      },
      new int[][] {
        new int[] {-1, 20},
        new int[] {8, 15},
      },
      new int[][] {
        new int[] {-1, 16},
        new int[] {22, 27},
      },
      new int[][] {
        new int[] {-1, 17},
        new int[] {24, 28},
      },
    };

    private static String[] errorMessages = {
      "expecting: id",
      "expecting: ':=', '(', id",
      "expecting: EOF",
      "expecting: id, EOF",
      "expecting: id, integer, string",
      "expecting: ')', id, integer, string",
      "expecting: ';'",
      "expecting: '+', '*', ';', ','",
      "expecting: '+', ';'",
      "expecting: ')'",
      "expecting: ','",
      "expecting: '+', ','",
    };

    private static int[] errors = {
      0, 1, 2, 3, 3, 3, 3, 3, 4, 5, 6, 3, 7, 7, 7, 8, 
      7, 7, 9, 10, 11, 3, 4, 3, 4, 6, 5, 7, 7, 3, 9, 
    };
}
}
